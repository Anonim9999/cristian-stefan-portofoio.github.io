# Junior Software Tester 
####Technical Skills: Python, C++, MATLAB - Simulink, CAPL, HTML, CSS, Java, Arduino, GitHub
## Work Experience
**Junior System Tester @Continental Automative Group**
- established the very first virtual testing entity (vECU) in cooperation with a team of newbies
- sucesfully harnessed the testing equipment resources as software labels and functions
- solve out over 68 bugs
- redesigned and fixed up to 20 measurement software functions
  
**Summer internship  @VNI(Vehicle netowrking) Departament Intern Continental AG**
- acquiring knoweldge in software and hardware architecutre
- learnt the ropes of debugging
- learnt the fundamentals of Python and CAPL
- gained hands on experience with basis testing procedures (rooting and flashing)

**Participant Cyber Tech Tournament, Sibiu(România)**
- fully developed from scratch the hardware and software architectures of a line-follower robot
- reacehd the semi-finals phase

Summary: *An exclusive competition for students in robotics, consisting of three stages (qualifiers, semifinals and
finals), aims to assist participants in developing various models of robots. These robots can range from simpler designs
like line followers or maze solvers to more sophisticated ones, such as cargo-carrying robots. The competition also
includes collective races to evaluate the robot's speed, efficiency and strength.*

## Education
- B.S, R.I.S. - Robotics and Intelligent Systems| The University of Lucian Blaga - 2018/2021
- M.S, Artificial Intelligence and Engineering Systems  | Eindhoven University of Technology - **2022 - On going**


## Personal Projects 
###Dijkstra and Time Monitoring algorithms for establishing a timing hierarchy – Pathfinding – Python - [as yet UNLISTED]

I used Dijkstra’s Algorithm to establish a timing hierarchy an optimize pathfinding in GTA San Andreas. The
purpose was not only to avoid the routes with obstacles such as traffic jams or harsh roads but also to
examine how different modes of transportation significantly impact the spectrum of timeframes. For the
instances, the Dijkstra’s Algorithm I implemented was slightly modified to factor in three variations (e.g.,
train – 5 hours; aeroplane – 2 hours; by foot – 7 hours; obstacle – 5 hours) as possible methods of
traveling from the given starting vertex to other one (n locations), whose lapse of time could vary
depending on the route’s constituents. Therefore, a route may be based on a mix of transportations
entities – aeroplane, train, by foot – or a single unit – e.g., travelling just by the plane. Besides calculating
the shortest path by carefully considering the traveling time spent with every means of transportation for
each segment the algorithm was also capable to deliver a hierarchy which ranks every combination of
routes from the shortest one to the longest. Hence, additionally I implemented a time monitoring algorithm
which had two roles: identifying when a new time lapse arises and finding its specific position into
hierarchy.

![image](https://github.com/Anonim9999/cristian-stefan-portofoio.github.io/assets/117277435/75735e74-01ef-4041-999e-3c4969bc7043)

###Fibonacci algorithm for predicting the degree in which unfinished tasks undermine team’s productivity – Agile Paradigm – C++ - [as yet UNLISTED]

In order to generate a graphic representation of the variation of team’s productivity I implemented a
Fibonacci based algorithm which determined how regularly missing deadlines will undermine the team’s
capacity[1]. Hence, the calculation relied on two identical sprints[2] – the first one = 2 weeks; the second one
= 3 weeks – aiming to highlight how an additional number of unfinished tasks coming from the first period
will overload the future workload and consequently affect the team’s productivity. The Fibonacci
sequence’s role was to gradually emit tasks throughout these two periods of time without exceeding the
maximum number of working days within each one. The first bunch of tasks (assuming that in this period
there were no tasks accomplished - First sprint – 10 days – Fibonacci (10) = 34 unfinished tasks) will
provide a lack of 272 hours, which will automatically impact the further period. Therefore, the second
sprint will be affected by the first one, mainly influencing the team capacity.
1 - how much time the team has available within the sprint to complete high-quality work; 2 - a dedicated period of time in which a set amount of work will be
completed on a project

###Min Priority QUEUE - using Python - [as yet UNLISTED]

Probably, one of the most common data structures I dealt with implementing a Min Priority
Queue – using Python – in the attempt to create a coordinator network which could effectively
handle incoming messages by prioritizing its “entities” – generally key levels ranging from 1 to 5.
Furthermore, the priority queue’s design relied on a regular Binary Heap. A difficult demand of
this assignment concerned the spectrum of rules/constraints which were supposed to be
implemented as priority laws in accordance with Protocol’s transportation standard (Ethernet:
priority 1); LIN:2; CAN:3; CAN FD:4; FlexRay:5; where: 1 is the protocol with the highest priority
and 5 the protocol with the lowest priority) and other additional exception – after a specific period
in which a message was not sent it might be necessary to change its key level from higher to
lower due to the system’s behaviour (e.g. DecreaseKey Op, Extract Min Op).

![image](https://github.com/Anonim9999/cristian-stefan-portofoio.github.io/assets/117277435/9a432c72-4eeb-4d1c-95c6-8a6a199f7415)

### Future pursuits   
  
